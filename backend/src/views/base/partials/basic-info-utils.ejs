<style>
  [data-print-header] {
    display: none;
  }

  @media print {
    body * {
      visibility: hidden;
    }
    [data-print-area],
    [data-print-area] * {
      visibility: visible;
    }
    [data-print-area] {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      color: #111827;
      direction: var(--print-direction, ltr);
      unicode-bidi: plaintext;
    }
    [data-print-header] {
      display: block;
      margin-bottom: 12px;
      color: #111827;
    }
    [data-print-area] table {
      border-collapse: collapse;
      width: 100%;
    }
    [data-print-area] th,
    [data-print-area] td {
      color: #111827;
      border-bottom: 1px solid #e5e7eb;
    }
    [data-print-area] {
      overflow: visible !important;
      max-height: none !important;
    }
    [data-print-area] .overflow-x-auto {
      overflow: visible !important;
    }
    [data-print-area] .sticky-col-1,
    [data-print-area] .sticky-col-2,
    [data-print-area] .sticky-col-3 {
      position: static !important;
      left: auto !important;
      z-index: auto !important;
      min-width: auto !important;
      width: auto !important;
    }
    [data-print-area] table {
      table-layout: auto;
    }
    [data-print-area] th,
    [data-print-area] td {
      white-space: normal;
      word-break: break-word;
      overflow-wrap: anywhere;
    }
    @page {
      margin: 12mm;
      size: auto;
    }
  }

  .multi-tag {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    border: 1px solid #e2e8f0;
    border-radius: 9999px;
    padding: 4px 10px;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: #475569;
    background: #fff;
  }

  .multi-tag button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 18px;
    height: 18px;
    border-radius: 9999px;
    border: 1px solid #e2e8f0;
    color: #64748b;
    transition:
      color 0.2s ease,
      border-color 0.2s ease;
  }

  .multi-tag button:hover {
    color: #0f172a;
    border-color: #cbd5f5;
  }

  [data-multi-select] [data-multi-menu] {
    width: 100%;
    max-width: 100%;
  }

  @media (max-width: 640px) {
    [data-multi-select] [data-multi-menu] {
      max-width: calc(100vw - 2rem);
    }
  }

  .sticky-col-1,
  .sticky-col-2,
  .sticky-col-3 {
    position: sticky;
    background: #fff;
  }

  thead .sticky-col-1,
  thead .sticky-col-2,
  thead .sticky-col-3 {
    background: #f8fafc;
    z-index: 3;
  }

  .sticky-col-1 {
    left: 0;
    min-width: 180px;
    z-index: 2;
  }

  .sticky-col-2 {
    left: 180px;
    min-width: 160px;
    z-index: 1;
  }

  .sticky-col-3 {
    left: 340px;
    min-width: 200px;
    z-index: 1;
  }

  @media (max-width: 640px) {
    [data-modal] {
      align-items: flex-end;
    }

    [data-modal] > div {
      width: 100%;
      max-width: 100%;
      border-radius: 18px 18px 0 0;
      margin: 0;
    }

    [data-modal] select {
      max-width: 100%;
    }

    .sticky-col-1,
    .sticky-col-2,
    .sticky-col-3 {
      position: static;
      left: auto;
      min-width: auto;
      z-index: auto;
    }
  }

  [data-compact-table] th,
  [data-compact-table] td {
    padding-left: 0.5rem;
    padding-right: 0.5rem;
    white-space: normal;
    word-break: break-word;
    overflow-wrap: anywhere;
  }
</style>

<script>
  (function () {
    // Wire up modal, filters, sorting, export, and table actions.
    const modal = document.querySelector("[data-modal]");
    const modalForm = document.querySelector("[data-modal-form]");
    const modalTitle = document.querySelector("[data-modal-title]");
    const openButtons = document.querySelectorAll("[data-modal-open]");
    const closeButtons = document.querySelectorAll("[data-modal-close]");
    const editButtons = document.querySelectorAll("[data-edit]");
    const searchInput = document.querySelector("[data-search-input]");
    const pageSizeSelect = document.querySelector("[data-page-size]");
    const prevButton = document.querySelector("[data-prev-page]");
    const nextButton = document.querySelector("[data-next-page]");
    const pageIndicator = document.querySelector("[data-page-indicator]");
    const downloadButton = document.querySelector("[data-download-button]");
    const printButton = document.querySelector("[data-print-button]");
    const sortButtons = Array.from(document.querySelectorAll("[data-sort-key]"));
    const tableBody = document.querySelector("[data-table-body]");
    const statusFilter = document.querySelector("[data-status-filter]");
    const filterToggle = document.querySelector("[data-filter-toggle]");
    const filterPanel = document.querySelector("[data-filter-panel]");
    const filterAccountType = document.querySelector("[data-filter-account-type]");
    const filterAccountGroup = document.querySelector("[data-filter-account-group]");
    const filterPartyType = document.querySelector("[data-filter-party-type]");
    const filterPartyGroup = document.querySelector("[data-filter-party-group]");
    const filterBranch = document.querySelector("[data-filter-branch]");
    const filterCity = document.querySelector("[data-filter-city]");
    const filterCreatedBy = document.querySelector("[data-filter-created-by]");
    const filterSubgroup = document.querySelector("[data-filter-subgroup]");
    const filterCreatedAtStart = document.querySelector("[data-filter-created-at-start]");
    const filterCreatedAtEnd = document.querySelector("[data-filter-created-at-end]");
    const filterAddButtons = document.querySelectorAll("[data-filter-add]");
    const filterClose = document.querySelector("[data-filter-close]");
    const filterApply = document.querySelector("[data-filter-apply]");
    const filterClear = document.querySelector("[data-filter-clear]");
    const filterCountBadge = document.querySelector("[data-filter-count]");
    const confirmModal = document.querySelector("[data-confirm-modal]");
    const confirmForm = document.querySelector("[data-confirm-form]");
    const confirmTitle = document.querySelector("[data-confirm-title]");
    const confirmMessage = document.querySelector("[data-confirm-message]");
    const confirmClose = document.querySelectorAll("[data-confirm-close]");
    const toggleButtons = document.querySelectorAll("[data-toggle]");
    const deleteButtons = document.querySelectorAll("[data-delete]");
    const rowMenuButtons = document.querySelectorAll("[data-row-menu]");
    const rowMenuPanels = document.querySelectorAll("[data-row-menu-panel]");
    const modalError = document.querySelector("[data-modal-error]");
    const auditPanel = document.querySelector("[data-audit-panel]");
    const auditCreated = document.querySelector("[data-audit-created]");
    const auditUpdated = document.querySelector("[data-audit-updated]");
    const i18n = {
      add: '<%= t("add") %>',
      edit: '<%= t("edit") %>',
      confirm: '<%= t("confirm") %>',
      proceedChange: '<%= t("proceed_change") %>',
      permanentDelete: '<%= t("permanent_delete") %>',
      permanentDeleteMessage: '<%= t("permanent_delete_message") %>',
      showing: '<%= t("showing") %>',
      to: '<%= t("to") %>',
      of: '<%= t("of") %>',
      entries: '<%= t("entries") %>',
      unitCodeExists: '<%= t("unit_code_exists") %>',
      conversionSame: '<%= t("conversion_same_units") %>',
      conversionFactor: '<%= t("conversion_factor") %>',
      conversionExists: '<%= t("conversion_exists") %>',
      selectBranch: '<%= t("error_select_branch") %>',
      selectPhone: '<%= t("error_select_phone") %>',
    };
    const printDirection = '<%= locale === "ur" ? "rtl" : "ltr" %>';
    if (typeof document !== "undefined" && document.documentElement) {
      document.documentElement.style.setProperty("--print-direction", printDirection);
    }
    let filterPartyGroups = null;

    const getFilterValues = (selector) =>
      Array.from(document.querySelectorAll(selector))
        .map((el) => (el.value || "").trim())
        .filter(Boolean);

    const updateFilterCount = () => {
      if (!filterCountBadge) return;
      const createdByActive = filterCreatedBy && (filterCreatedBy.value || "").trim() ? 1 : 0;
      const subgroupActive = filterSubgroup && (filterSubgroup.value || "").trim() ? 1 : 0;
      const createdAtActive = (filterCreatedAtStart && filterCreatedAtStart.value) || (filterCreatedAtEnd && filterCreatedAtEnd.value) ? 1 : 0;
      const activeFilters = [...getFilterValues("[data-filter-account-type]"), ...getFilterValues("[data-filter-account-group]"), ...getFilterValues("[data-filter-party-type]"), ...getFilterValues("[data-filter-party-group]"), ...getFilterValues("[data-filter-branch]"), ...getFilterValues("[data-filter-city]")].length + createdByActive + createdAtActive + subgroupActive;
      if (activeFilters > 0) {
        filterCountBadge.textContent = String(activeFilters);
        filterCountBadge.classList.remove("hidden");
      } else {
        filterCountBadge.classList.add("hidden");
      }
    };

    const autoCodeEnabled = "<%= page.autoCodeFromName ? 'true' : 'false' %>" === "true";
    const pageTitle = "<%= t(page.titleKey) %>";
    const basePath = "<%= basePath %>";
    const i18nSelect = '<%= t("select") %>';
    const i18nSelected = '<%= t("selected") %>';
    const i18nAll = '<%= t("all") %>';
    const i18nSearchInput = '<%= t("search") %>';

    const cleanModalPath = () => {
      if (typeof window === "undefined" || !window.history || !window.location || !basePath) return;
      const currentPath = window.location.pathname || "";
      if (!currentPath.startsWith(basePath)) return;
      const suffix = currentPath.slice(basePath.length);
      if (!suffix) return;
      if (/^\/\d+(\/.*)?$/.test(suffix)) {
        window.history.replaceState(null, "", basePath);
      }
    };
    cleanModalPath();

    const openModal = (mode, data) => {
      cleanModalPath();
      if (!modal || !modalForm) return;
      const payload = data || {};
      // Populate modal fields from row data (or defaults on create).
      modal.classList.remove("hidden");
      modal.classList.add("flex");
      modal.dataset.mode = mode;
      modalTitle.textContent = mode === "edit" ? i18n.edit + " " + pageTitle : i18n.add + " " + pageTitle;
      modalForm.setAttribute("action", payload.action || basePath);
      modal.dataset.currentId = payload.id || "";
      modalForm.querySelectorAll("[data-field]").forEach((input) => {
        const name = input.getAttribute("data-field");
        if (input.type === "checkbox") {
          if (input.dataset.multi === "true") {
            const selected = (payload[name] || "")
              .split(",")
              .map((value) => value.trim())
              .filter(Boolean);
            input.checked = selected.includes(input.value);
          } else {
            input.checked = payload[name] === "true" || payload[name] === true;
          }
        } else if (input.tagName === "SELECT" && input.multiple) {
          const selected = (payload[name] || "")
            .split(",")
            .map((value) => value.trim())
            .filter(Boolean);
          Array.from(input.options).forEach((option) => {
            option.selected = selected.includes(option.value);
          });
        } else {
          input.value = payload[name] || "";
        }
      });
      modalForm.querySelectorAll("[data-hide-on-create]").forEach((node) => {
        if (mode === "create") {
          node.classList.add("hidden");
        } else {
          node.classList.remove("hidden");
        }
      });
      if (modalError) {
        modalError.textContent = "";
        modalError.hidden = true;
      }
      if (auditPanel && mode === "edit") {
        auditPanel.hidden = false;
        if (auditCreated) {
          auditCreated.textContent = payload.created_at ? payload.created_at + (payload.created_by ? " by " + payload.created_by : "") : "-";
        }
        if (auditUpdated) {
          auditUpdated.textContent = payload.updated_at ? payload.updated_at + (payload.updated_by ? " by " + payload.updated_by : "") : "-";
        }
      } else if (auditPanel) {
        auditPanel.hidden = true;
      }
      if (mode === "create" && autoCodeEnabled) {
        const codeInput = modalForm.querySelector('[data-field="code"]');
        if (codeInput) {
          codeInput.dataset.userEdited = "false";
        }
      }
      refreshMultiSelects();
      document.dispatchEvent(new CustomEvent("modal:opened", { detail: { mode } }));
    };

    const closeModal = () => {
      if (!modal) return;
      modal.classList.add("hidden");
      modal.classList.remove("flex");
      cleanModalPath();
    };

    const openConfirm = (title, message, action) => {
      if (!confirmModal || !confirmForm) return;
      confirmTitle.textContent = title || i18n.confirm;
      confirmMessage.textContent = message || '<%= t("are_you_sure") %>';
      confirmForm.setAttribute("action", action || "");
      confirmModal.classList.remove("hidden");
      confirmModal.classList.add("flex");
    };

    const closeConfirm = () => {
      if (!confirmModal) return;
      confirmModal.classList.add("hidden");
      confirmModal.classList.remove("flex");
    };

    let currentPage = 1;
    let pageSizeRaw = (pageSizeSelect && pageSizeSelect.value) || "10";
    let pageSize = pageSizeRaw === "all" ? Number.POSITIVE_INFINITY : Number(pageSizeRaw);
    let sortIndex = null;
    let sortDir = "asc";
    let sortType = "text";

    const getRows = () => Array.from(document.querySelectorAll("[data-row]"));

    const initializeRows = () => {
      getRows().forEach((row, index) => {
        if (!row.dataset.origIndex) {
          row.dataset.origIndex = String(index);
        }
      });
    };

    const normalizeValue = (value, type) => {
      const trimmed = (value || "").trim();
      if (!trimmed) return type === "number" ? 0 : "";
      if (type === "number") {
        const numberValue = Number(trimmed.replace(/[^0-9.-]+/g, ""));
        return Number.isNaN(numberValue) ? 0 : numberValue;
      }
      if (type === "date") {
        const dateValue = Date.parse(trimmed);
        return Number.isNaN(dateValue) ? 0 : dateValue;
      }
      return trimmed.toLowerCase();
    };

    const sortRows = (rows) => {
      if (sortIndex === null) {
        return rows.slice().sort((a, b) => {
          const aIndex = Number(a.dataset.origIndex || 0);
          const bIndex = Number(b.dataset.origIndex || 0);
          return aIndex - bIndex;
        });
      }

      const sorted = rows.slice().sort((a, b) => {
        const aCells = a.querySelectorAll("td");
        const bCells = b.querySelectorAll("td");
        const aCell = aCells[sortIndex];
        const bCell = bCells[sortIndex];
        const aRaw = aCell ? aCell.getAttribute("data-sort-value") || aCell.textContent : "";
        const bRaw = bCell ? bCell.getAttribute("data-sort-value") || bCell.textContent : "";
        const aValue = normalizeValue(aRaw, sortType);
        const bValue = normalizeValue(bRaw, sortType);
        if (aValue < bValue) return sortDir === "asc" ? -1 : 1;
        if (aValue > bValue) return sortDir === "asc" ? 1 : -1;
        const aIndex = Number(a.dataset.origIndex || 0);
        const bIndex = Number(b.dataset.origIndex || 0);
        return aIndex - bIndex;
      });

      if (tableBody) {
        sorted.forEach((row) => tableBody.appendChild(row));
      }
      return sorted;
    };

    const updateSortIndicators = () => {
      sortButtons.forEach((btn) => {
        const indicator = btn.querySelector("[data-sort-indicator]");
        if (!indicator) return;
        if (Number(btn.dataset.sortIndex) === sortIndex) {
          indicator.textContent = sortDir === "asc" ? "^" : "v";
        } else {
          indicator.textContent = "-";
        }
      });
    };

    const applyFilters = () => {
      // Filter, sort, and paginate rows in-memory for fast UI updates.
      const query = ((searchInput && searchInput.value) || "").trim().toLowerCase();
      const status = (statusFilter && statusFilter.value) || "all";
      const accountTypeFilters = getFilterValues("[data-filter-account-type]");
      const accountGroupFilters = getFilterValues("[data-filter-account-group]");
      const partyTypeFilters = getFilterValues("[data-filter-party-type]");
      const partyGroupFilters = getFilterValues("[data-filter-party-group]");
      const branchFilters = getFilterValues("[data-filter-branch]");
      const cityFilters = getFilterValues("[data-filter-city]");
      const createdByValue = (filterCreatedBy && filterCreatedBy.value ? filterCreatedBy.value : "").trim();
      const subgroupValue = (filterSubgroup && filterSubgroup.value ? filterSubgroup.value : "").trim();
      const createdAtStart = filterCreatedAtStart ? filterCreatedAtStart.value : "";
      const createdAtEnd = filterCreatedAtEnd ? filterCreatedAtEnd.value : "";
      const readFilterRows = (key) => {
        const rows = Array.from(document.querySelectorAll(`[data-filter-list="${key}"] [data-filter-${key}], [data-filter-list="${key}"] [data-filter-${key.replace("-", "_")}]`));
        const list = document.querySelector(`[data-filter-list="${key}"]`);
        if (!list) return { include: [], exclude: [] };
        const selects = Array.from(list.querySelectorAll(`[data-filter-${key}]`));
        const modes = Array.from(list.querySelectorAll(`[data-filter-${key}-mode]`));
        const include = [];
        const exclude = [];
        selects.forEach((select, idx) => {
          const value = (select.value || "").trim();
          if (!value) return;
          const mode = (modes[idx] && modes[idx].value) || "include";
          if (mode === "exclude") {
            exclude.push(value);
          } else {
            include.push(value);
          }
        });
        return { include, exclude };
      };
      const accountTypeModes = readFilterRows("account-type");
      const accountGroupModes = readFilterRows("account-group");
      const partyTypeModes = readFilterRows("party-type");
      const partyGroupModes = readFilterRows("party-group");
      const branchModes = readFilterRows("branch");
      const cityModes = readFilterRows("city");
      const rows = getRows();
      const sorted = sortRows(rows);
      const filtered = sorted.filter((row) => {
        const matchesText = !query || row.textContent.toLowerCase().includes(query);
        if (!matchesText) return false;
        if (status !== "all") {
          const isActive = row.dataset.active === "true";
          if (status === "active" ? !isActive : isActive) return false;
        }
        if (accountTypeModes.include.length) {
          const matches = accountTypeModes.include.includes(row.dataset.accountType || "");
          if (!matches) return false;
        }
        if (accountTypeModes.exclude.length) {
          const matches = accountTypeModes.exclude.includes(row.dataset.accountType || "");
          if (matches) return false;
        }
        if (accountGroupModes.include.length) {
          const matches = accountGroupModes.include.includes(row.dataset.accountGroup || "");
          if (!matches) return false;
        }
        if (accountGroupModes.exclude.length) {
          const matches = accountGroupModes.exclude.includes(row.dataset.accountGroup || "");
          if (matches) return false;
        }
        if (partyTypeModes.include.length) {
          const matches = partyTypeModes.include.includes(row.dataset.partyType || "");
          if (!matches) return false;
        }
        if (partyTypeModes.exclude.length) {
          const matches = partyTypeModes.exclude.includes(row.dataset.partyType || "");
          if (matches) return false;
        }
        if (partyGroupModes.include.length) {
          const matches = partyGroupModes.include.includes(row.dataset.partyGroup || "");
          if (!matches) return false;
        }
        if (partyGroupModes.exclude.length) {
          const matches = partyGroupModes.exclude.includes(row.dataset.partyGroup || "");
          if (matches) return false;
        }
        if (cityModes.include.length) {
          const matches = cityModes.include.includes(row.dataset.city || "");
          if (!matches) return false;
        }
        if (cityModes.exclude.length) {
          const matches = cityModes.exclude.includes(row.dataset.city || "");
          if (matches) return false;
        }
        if (branchModes.include.length || branchModes.exclude.length) {
          const branches = (row.dataset.branch || "")
            .split(",")
            .map((value) => value.trim())
            .filter(Boolean);
          if (branchModes.include.length) {
            const matches = branchModes.include.some((value) => branches.includes(value));
            if (!matches) return false;
          }
          if (branchModes.exclude.length) {
            const matches = branchModes.exclude.some((value) => branches.includes(value));
            if (matches) return false;
          }
        }
        if (createdByValue) {
          const matches = (row.dataset.createdBy || "") === createdByValue;
          if (!matches) return false;
        }
        if (subgroupValue) {
          const matches = (row.dataset.subgroupId || "") === subgroupValue;
          if (!matches) return false;
        }
        if (createdAtStart || createdAtEnd) {
          const rowDateValue = row.dataset.createdAt || "";
          const rowTime = Date.parse(rowDateValue);
          if (Number.isNaN(rowTime)) return false;
          if (createdAtStart) {
            const startTime = Date.parse(createdAtStart);
            if (!Number.isNaN(startTime) && rowTime < startTime) return false;
          }
          if (createdAtEnd) {
            const endTime = Date.parse(createdAtEnd);
            if (!Number.isNaN(endTime) && rowTime > endTime) return false;
          }
        }
        return true;
      });

      let totalPages;
      let start;
      let end;
      if (!Number.isFinite(pageSize)) {
        // 'All' selected: show all rows, avoid arithmetic with Infinity which yields NaN
        totalPages = 1;
        currentPage = 1;
        start = 0;
        end = filtered.length;
      } else {
        totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
        currentPage = Math.min(currentPage, totalPages);
        start = (currentPage - 1) * pageSize;
        end = start + pageSize;
      }

      rows.forEach((row) => row.classList.add("hidden"));
      const visibleRows = filtered.slice(start, end);
      visibleRows.forEach((row) => row.classList.remove("hidden"));

      // --- HIDE EMPTY GROUPS (SKU PAGE) ---
      document.querySelectorAll(".sku-group-block").forEach((group) => {
        const groupRows = group.querySelectorAll("tr[data-row]");
        const anyVisible = Array.from(groupRows).some((r) => !r.classList.contains("hidden"));
        group.style.display = anyVisible ? "" : "none";
      });

      if (pageIndicator) {
        pageIndicator.textContent = String(currentPage);
      }
      if (prevButton) {
        prevButton.disabled = currentPage <= 1;
        prevButton.classList.toggle("opacity-40", currentPage <= 1);
      }
      if (nextButton) {
        nextButton.disabled = currentPage >= totalPages;
        nextButton.classList.toggle("opacity-40", currentPage >= totalPages);
      }

      const showing = document.querySelector("[data-showing-count]");
      if (showing) {
        const startLabel = filtered.length === 0 ? 0 : start + 1;
        const endLabel = Math.min(start + visibleRows.length, filtered.length);
        showing.textContent = i18n.showing + " " + startLabel + " " + i18n.to + " " + endLabel + " " + i18n.of + " " + filtered.length + " " + i18n.entries;
      }
    };

    const cleanText = (value) => (value || "").replace(/\s+/g, " ").trim();

    const downloadCsv = () => {
      // Export only the currently visible rows (respects filters).
      const headers = Array.from(document.querySelectorAll("thead th"))
        .map((th) => cleanText(th.textContent))
        .filter((label) => label && label.toLowerCase() !== "actions");
      const rows = getRows().filter((row) => !row.classList.contains("hidden"));
      const csvRows = [headers.join(",")];
      rows.forEach((row) => {
        const cells = Array.from(row.querySelectorAll("td"))
          .slice(0, headers.length)
          .map((cell, idx) => {
            let datasetValue = cell.dataset.summaryRates || cell.dataset.summaryAvg || "";
            let value = datasetValue || cell.textContent;
            // If this is the Size column, format to prevent Excel date conversion
            if (headers[idx] && headers[idx].toLowerCase().includes("size")) {
              // If value matches N/N or N-N, prefix with S-
              if (/^\d{1,2}[\/\-]\d{1,2}$/.test(value.trim())) {
                value = `S-${value.trim()}`;
              }
            }
            return `"${cleanText(value).replace(/"/g, '""')}"`;
          });
        csvRows.push(cells.join(","));
      });

      const csvContent = "\uFEFF" + csvRows.join("\r\n");
      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = '<%= t(page.titleKey).replace(/\\s+/g, "_") %>_export.csv';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    };

    if (downloadButton) {
      downloadButton.addEventListener("click", downloadCsv);
    }
    if (printButton) {
      printButton.addEventListener("click", () => window.print());
    }
    if (searchInput) {
      searchInput.addEventListener("input", () => {
        currentPage = 1;
        applyFilters();
      });
    }
    if (statusFilter) {
      statusFilter.addEventListener("change", () => {
        currentPage = 1;
        applyFilters();
      });
    }
    const hookFilter = (element) => {
      if (!element) return;
      element.addEventListener("change", () => {
        currentPage = 1;
        updateFilterCount();
      });
    };
    const hookFilterAll = (selector) => {
      document.querySelectorAll(selector).forEach((el) => hookFilter(el));
    };
    hookFilterAll("[data-filter-account-type]");
    hookFilterAll("[data-filter-account-group]");
    hookFilterAll("[data-filter-party-type]");
    hookFilterAll("[data-filter-party-group]");
    hookFilterAll("[data-filter-branch]");
    hookFilterAll("[data-filter-city]");
    hookFilterAll("[data-filter-subgroup]");
    if (filterCreatedBy) filterCreatedBy.addEventListener("change", updateFilterCount);
    if (filterSubgroup) filterSubgroup.addEventListener("change", updateFilterCount);
    if (filterCreatedAtStart) filterCreatedAtStart.addEventListener("change", updateFilterCount);
    if (filterCreatedAtEnd) filterCreatedAtEnd.addEventListener("change", updateFilterCount);
    document.querySelectorAll("[data-filter-account-type-mode]").forEach((el) => hookFilter(el));
    document.querySelectorAll("[data-filter-account-group-mode]").forEach((el) => hookFilter(el));
    document.querySelectorAll("[data-filter-party-type-mode]").forEach((el) => hookFilter(el));
    document.querySelectorAll("[data-filter-party-group-mode]").forEach((el) => hookFilter(el));
    document.querySelectorAll("[data-filter-branch-mode]").forEach((el) => hookFilter(el));
    document.querySelectorAll("[data-filter-city-mode]").forEach((el) => hookFilter(el));
    ["[data-filter-account-type]", "[data-filter-account-group]", "[data-filter-party-type]", "[data-filter-party-group]", "[data-filter-branch]", "[data-filter-city]"].forEach((selector) => {
      document.querySelectorAll(selector).forEach((el) => {
        el.addEventListener("change", updateFilterCount);
      });
    });
    if (pageSizeSelect) {
      pageSizeSelect.addEventListener("change", () => {
        pageSizeRaw = pageSizeSelect.value || "10";
        pageSize = pageSizeRaw === "all" ? Number.POSITIVE_INFINITY : Number(pageSizeRaw);
        currentPage = 1;
        applyFilters();
      });
    }
    if (prevButton) {
      prevButton.addEventListener("click", () => {
        if (currentPage > 1) {
          currentPage -= 1;
          applyFilters();
        }
      });
    }
    if (nextButton) {
      nextButton.addEventListener("click", () => {
        currentPage += 1;
        applyFilters();
      });
    }

    toggleButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        openConfirm(btn.dataset.toggleLabel || i18n.confirm, i18n.proceedChange, btn.dataset.toggleAction);
      });
    });

    deleteButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        openConfirm(i18n.permanentDelete, i18n.permanentDeleteMessage, btn.dataset.deleteAction);
      });
    });

    const closeRowMenus = (except) => {
      rowMenuPanels.forEach((panel) => {
        if (panel === except) return;
        panel.classList.add("hidden");
      });
    };

    rowMenuButtons.forEach((btn) => {
      btn.addEventListener("click", (event) => {
        event.stopPropagation();
        const panel = btn.parentElement.querySelector("[data-row-menu-panel]");
        if (!panel) return;
        const willOpen = panel.classList.contains("hidden");
        closeRowMenus();
        if (willOpen) {
          panel.classList.remove("hidden");
        }
      });
    });

    rowMenuPanels.forEach((panel) => {
      panel.addEventListener("click", (event) => {
        event.stopPropagation();
      });
    });

    confirmClose.forEach((btn) => {
      btn.addEventListener("click", closeConfirm);
    });

    if (confirmModal) {
      confirmModal.addEventListener("click", (event) => {
        if (event.target === confirmModal) {
          closeConfirm();
        }
      });
    }

    document.addEventListener("click", () => {
      closeRowMenus();
    });

    const handleSortClick = (btn) => {
      if (!btn) return;
      const index = Number(btn.dataset.sortIndex);
      if (!Number.isFinite(index)) return;
      sortType = btn.dataset.sortType || "text";
      if (sortIndex === index) {
        sortDir = sortDir === "asc" ? "desc" : "asc";
      } else {
        sortIndex = index;
        sortDir = "asc";
      }
      updateSortIndicators();
      currentPage = 1;
      applyFilters();
    };

    const table = document.querySelector("[data-table]");
    if (table) {
      table.addEventListener("click", (event) => {
        const btn = event.target.closest("[data-sort-key]");
        if (!btn) return;
        event.preventDefault();
        handleSortClick(btn);
      });
    }

    openButtons.forEach((btn) => {
      btn.addEventListener("click", () => openModal("create", { id: "" }));
    });

    editButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const data = {
          id: btn.dataset.id,
          action: basePath + "/" + btn.dataset.id,
          created_at: btn.dataset.createdAt || "",
          created_by: btn.dataset.createdBy || "",
          updated_at: btn.dataset.updatedAt || "",
          updated_by: btn.dataset.updatedBy || "",
        };
        Object.keys(btn.dataset).forEach((key) => {
          if (key !== "id") {
            data[key] = btn.dataset[key];
          }
        });
        openModal("edit", data);
      });
    });

    closeButtons.forEach((btn) => {
      btn.addEventListener("click", closeModal);
    });

    if (modal) {
      modal.addEventListener("click", (event) => {
        if (event.target === modal) {
          closeModal();
        }
      });
    }

    initializeRows();
    updateSortIndicators();
    if (modalForm) {
      const pageKey = "<%= page.titleKey %>";
      // Parties: filter party groups to match the selected party type (customer/supplier/both).
      if (pageKey === "parties") {
        // Locate the party type and group selects inside the modal form.
        const partyType = modalForm.querySelector('[data-field="party_type"]');
        const groupSelect = modalForm.querySelector('[data-field="group_id"]');
        // Cache the full list of group options for rebuilding on each change.
        const allGroupOptions = groupSelect ? Array.from(groupSelect.options) : [];
        const filterGroups = () => {
          if (!partyType || !groupSelect) return;
          // Normalize the selected type for case-insensitive matching.
          const selectedType = (partyType.value || "").toUpperCase();
          // Remember current selection to restore it if it still matches.
          const previous = groupSelect.value;
          // Rebuild the dropdown options based on the selected party type.
          groupSelect.innerHTML = "";
          allGroupOptions.forEach((opt) => {
            const optValue = opt.value || "";
            // Always keep the empty "Select" option.
            // if (!optValue) {
            //   groupSelect.appendChild(opt.cloneNode(true));
            //   return;
            // }
            // Match against the party type stored on each option.
            const optType = (opt.getAttribute("data-party-type") || "").replace(/["']/g, "").toUpperCase();
            if (!selectedType || optType === "BOTH" || optType === selectedType) {
              groupSelect.appendChild(opt.cloneNode(true));
            }
          });
          // Restore previous selection if it still exists after filtering.
          if (previous) {
            groupSelect.value = previous;
            if (groupSelect.value !== previous) {
              groupSelect.value = "";
            }
          }
        };
        if (partyType && groupSelect) {
          // Re-filter whenever the party type changes.
          partyType.addEventListener("change", filterGroups);
          // Expose for re-use when the modal opens.
          filterPartyGroups = filterGroups;
          // Apply once on load so the list matches the current selection.
          filterGroups();
        }
      }
      if (autoCodeEnabled) {
        const nameInput = modalForm.querySelector('[data-field="name"]');
        const codeInput = modalForm.querySelector('[data-field="code"]');
        const toCode = (value) =>
          (value || "")
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, "_")
            .replace(/^_+|_+$/g, "")
            .slice(0, 50);

        if (codeInput) {
          codeInput.dataset.userEdited = "false";
          codeInput.addEventListener("input", () => {
            const trimmed = (codeInput.value || "").trim();
            codeInput.dataset.userEdited = trimmed ? "true" : "false";
          });
        }

        if (nameInput && codeInput) {
          nameInput.addEventListener("input", () => {
            if (modal.dataset.mode !== "create") return;
            if (codeInput.dataset.userEdited === "true") return;
            codeInput.value = toCode(nameInput.value);
          });
        }
      }

      modalForm.addEventListener("submit", (event) => {
        if (!modal) return;
        const pageKey = "<%= page.titleKey %>";
        const currentId = modal.dataset.currentId || "";

        if (pageKey === "accounts" || pageKey === "parties") {
          const branchSelect = modalForm.querySelector('[data-field="branch_ids"]');
          if (branchSelect && branchSelect.multiple) {
            const selected = Array.from(branchSelect.options).filter((opt) => opt.selected);
            if (!selected.length) {
              event.preventDefault();
              if (modalError) {
                modalError.textContent = i18n.selectBranch;
                modalError.hidden = false;
              }
              return;
            }
          }
        }
        if (pageKey === "parties") {
          const phone1 = modalForm.querySelector('[data-field="phone1"]');
          const phone2 = modalForm.querySelector('[data-field="phone2"]');
          if (phone1) {
            const phone1Value = phone1.value.trim();
            if (!phone1Value) {
              event.preventDefault();
              if (modalError) {
                modalError.textContent = i18n.selectPhone;
                modalError.hidden = false;
              }
              return;
            }
          }
        }

        if (pageKey === "units") {
          const codeInput = modalForm.querySelector('[data-field="code"]');
          const codeValue = codeInput ? codeInput.value.trim().toLowerCase() : "";
          if (codeValue) {
            const exists = getRows().some((row) => {
              const rowCode = (row.dataset.code || "").trim().toLowerCase();
              const rowId = row.querySelector("[data-edit]")?.dataset.id || "";
              return rowCode === codeValue && rowId !== currentId;
            });
            if (exists) {
              event.preventDefault();
              if (modalError) {
                modalError.textContent = i18n.unitCodeExists;
                modalError.hidden = false;
              }
              return;
            }
          }
        }

        if (pageKey === "uom_conversions") {
          const fromInput = modalForm.querySelector('[data-field="from_uom_id"]');
          const toInput = modalForm.querySelector('[data-field="to_uom_id"]');
          const factorInput = modalForm.querySelector('[data-field="factor"]');
          const fromValue = fromInput ? fromInput.value : "";
          const toValue = toInput ? toInput.value : "";
          const factorValue = factorInput ? Number(factorInput.value) : 0;
          if (fromValue && toValue && fromValue === toValue) {
            event.preventDefault();
            if (modalError) {
              modalError.textContent = i18n.conversionSame;
              modalError.hidden = false;
            }
            return;
          }
          if (!factorValue || factorValue <= 0) {
            event.preventDefault();
            if (modalError) {
              modalError.textContent = i18n.conversionFactor;
              modalError.hidden = false;
            }
            return;
          }
          const exists = getRows().some((row) => {
            const rowFrom = row.dataset.from || "";
            const rowTo = row.dataset.to || "";
            const rowId = row.querySelector("[data-edit]")?.dataset.id || "";
            return rowFrom === fromValue && rowTo === toValue && rowId !== currentId;
          });
          if (exists) {
            event.preventDefault();
            if (modalError) {
              modalError.textContent = i18n.conversionExists;
              modalError.hidden = false;
            }
          }
        }
      });
    }

    const initMultiSelect = (wrap) => {
      if (wrap.dataset.multiReady === "true") return;
      wrap.dataset.multiReady = "true";
      const select = wrap.querySelector("select[multiple]");
      const tags = wrap.querySelector("[data-multi-tags]");
      const trigger = wrap.querySelector("[data-multi-trigger]");
      const menu = wrap.querySelector("[data-multi-menu]");
      const placeholder = wrap.querySelector("[data-multi-placeholder]");
      if (!select || !tags || !trigger || !menu || !placeholder) return;

      const closeMenu = () => {
        menu.classList.add("hidden");
      };

      const openMenu = () => {
        menu.classList.remove("hidden");
      };

      const toggleMenu = () => {
        menu.classList.contains("hidden") ? openMenu() : closeMenu();
      };

      const updateTags = () => {
        const selected = Array.from(select.options).filter((opt) => opt.selected);
        tags.innerHTML = "";
        if (!selected.length) {
          placeholder.textContent = i18nSelect;
          return;
        }
        placeholder.textContent = i18nSelected;
        selected.forEach((opt) => {
          const tag = document.createElement("span");
          tag.className = "multi-tag";
          tag.textContent = opt.textContent.trim();
          const remove = document.createElement("button");
          remove.type = "button";
          remove.innerHTML = "&times;";
          remove.addEventListener("click", (event) => {
            event.preventDefault();
            event.stopPropagation();
            opt.selected = false;
            select.dispatchEvent(new Event("change", { bubbles: true }));
            updateTags();
            renderMenu();
          });
          tag.appendChild(remove);
          tags.appendChild(tag);
        });
      };

      const searchInput = document.createElement("input");
      searchInput.type = "search";
      searchInput.autocomplete = "off";
      searchInput.placeholder = i18nSearchInput;
      searchInput.className = "mb-2 w-full rounded-xl border border-slate-200 bg-slate-50 px-3 py-2 text-xs text-slate-700 shadow-sm focus:border-slate-300 focus:outline-none focus:ring-2 focus:ring-accent/30";
      const optionsWrapper = document.createElement("div");
      optionsWrapper.className = "space-y-1";
      menu.innerHTML = "";
      menu.appendChild(searchInput);
      menu.appendChild(optionsWrapper);

      const renderMenu = () => {
        const filter = (searchInput.value || "").trim().toLowerCase();
        optionsWrapper.innerHTML = "";
        Array.from(select.options).forEach((opt) => {
          const labelText = opt.textContent.trim();
          const matches = !filter || labelText.toLowerCase().includes(filter);
          if (filter && !matches && !opt.selected) {
            return;
          }
          const option = document.createElement("button");
          option.type = "button";
          option.className = "flex w-full items-center justify-between rounded-lg px-3 py-2 text-left text-sm text-slate-700 transition hover:bg-amber-50/60";
          const label = document.createElement("span");
          label.textContent = labelText;
          const check = document.createElement("span");
          check.className = "text-xs text-slate-400";
          check.textContent = opt.selected ? "*" : "";
          option.appendChild(label);
          option.appendChild(check);
          option.addEventListener("click", (event) => {
            event.preventDefault();
            event.stopPropagation();
            opt.selected = !opt.selected;
            select.dispatchEvent(new Event("change", { bubbles: true }));
            updateTags();
            renderMenu();
            closeMenu();
          });
          optionsWrapper.appendChild(option);
        });
      };

      searchInput.addEventListener("input", () => {
        renderMenu();
      });

      updateTags();
      renderMenu();
      wrap._multiUpdate = updateTags;
      wrap._multiMenu = renderMenu;
      wrap._multiSearchInput = searchInput;

      trigger.addEventListener("click", (event) => {
        event.preventDefault();
        event.stopPropagation();
        toggleMenu();
      });
      menu.addEventListener("click", (event) => {
        event.stopPropagation();
      });
      select.addEventListener("change", () => {
        updateTags();
        if (typeof wrap._multiMenu === "function") {
          wrap._multiMenu();
        }
      });
      document.addEventListener("click", (event) => {
        if (!wrap.contains(event.target)) {
          closeMenu();
        }
      });
    };

    const refreshMultiSelects = () => {
      document.querySelectorAll("[data-multi-select]").forEach((wrap) => {
        initMultiSelect(wrap);
        const select = wrap.querySelector("select[multiple]");
        const tags = wrap.querySelector("[data-multi-tags]");
        const placeholder = wrap.querySelector("[data-multi-placeholder]");
        if (!select || !tags || !placeholder) return;
        if (wrap._multiSearchInput) {
          wrap._multiSearchInput.value = "";
        }
        if (typeof wrap._multiMenu === "function") {
          wrap._multiMenu();
        }
        if (typeof wrap._multiUpdate === "function") {
          wrap._multiUpdate();
        }
      });
    };

    const buildFilterOptions = () => {
      if (!filterPanel) return;
      const rows = getRows();
      const collect = (key) => Array.from(new Set(rows.map((row) => (row.dataset[key] || "").trim()).filter(Boolean))).sort();
      const accountTypes = collect("accountType");
      const accountGroups = collect("accountGroup");
      const partyTypes = collect("partyType");
      const partyGroups = collect("partyGroup");
      const branches = Array.from(
        new Set(
          rows
            .flatMap((row) => (row.dataset.branch || "").split(","))
            .map((value) => value.trim())
            .filter(Boolean),
        ),
      ).sort();
      const cities = collect("city");

      const fillSelectAll = (selector, values) => {
        const options = [""].concat(values);
        document.querySelectorAll(selector).forEach((select) => {
          const current = select.value;
          select.innerHTML = "";
          options.forEach((value) => {
            const option = document.createElement("option");
            option.value = value;
            option.textContent = value || i18nAll;
            select.appendChild(option);
          });
          select.value = current;
        });
      };

      fillSelectAll("[data-filter-account-type]", accountTypes);
      fillSelectAll("[data-filter-account-group]", accountGroups);
      fillSelectAll("[data-filter-party-type]", partyTypes);
      fillSelectAll("[data-filter-party-group]", partyGroups);
      fillSelectAll("[data-filter-branch]", branches);
      fillSelectAll("[data-filter-city]", cities);
    };

    if (typeof filterPartyGroups === "function") {
      filterPartyGroups();
    }
    refreshMultiSelects();
    buildFilterOptions();
    updateFilterCount();

    const autoResizeTextareas = () => {
      document.querySelectorAll("textarea[data-auto-resize]").forEach((area) => {
        const resize = () => {
          area.style.height = "auto";
          area.style.height = `${area.scrollHeight}px`;
        };
        area.addEventListener("input", resize);
        resize();
      });
    };

    autoResizeTextareas();

    if (filterToggle && filterPanel) {
      const openFilters = () => filterPanel.classList.remove("hidden");
      const closeFilters = () => filterPanel.classList.add("hidden");
      filterToggle.addEventListener("click", openFilters);
      if (filterClose) {
        filterClose.addEventListener("click", closeFilters);
      }
      if (filterApply) {
        filterApply.addEventListener("click", () => {
          const useServerFilters = filterPanel && filterPanel.dataset.filterServer === "true";
          if (useServerFilters) {
            const url = new URL(window.location.href);
            const params = new URLSearchParams(url.search);
            const subgroupValue = (filterSubgroup && filterSubgroup.value ? filterSubgroup.value : "").trim();
            const createdByValue = (filterCreatedBy && filterCreatedBy.value ? filterCreatedBy.value : "").trim();
            const createdAtStartValue = filterCreatedAtStart ? filterCreatedAtStart.value : "";
            const createdAtEndValue = filterCreatedAtEnd ? filterCreatedAtEnd.value : "";
            const lowStockOnly = filterPanel.querySelector('[name="low_stock_only"]');

            if (subgroupValue) {
              params.set("subgroup_id", subgroupValue);
            } else {
              params.delete("subgroup_id");
            }
            if (createdByValue) {
              params.set("created_by", createdByValue);
            } else {
              params.delete("created_by");
            }
            if (createdAtStartValue) {
              params.set("created_at_start", createdAtStartValue);
            } else {
              params.delete("created_at_start");
            }
            if (createdAtEndValue) {
              params.set("created_at_end", createdAtEndValue);
            } else {
              params.delete("created_at_end");
            }
            if (lowStockOnly && lowStockOnly.checked) {
              params.set("low_stock_only", "true");
            } else {
              params.delete("low_stock_only");
            }

            url.search = params.toString();
            window.location.href = url.toString();
            return;
          }

          applyFilters();
          updateFilterCount();
          closeFilters();
        });
      }
      if (filterClear) {
        filterClear.addEventListener("click", () => {
          const useServerFilters = filterPanel && filterPanel.dataset.filterServer === "true";
          if (useServerFilters) {
            const url = new URL(window.location.href);
            const params = new URLSearchParams(url.search);
            ["subgroup_id", "created_by", "created_at_start", "created_at_end", "low_stock_only"].forEach((key) => params.delete(key));
            url.search = params.toString();
            window.location.href = url.toString();
            return;
          }
          ["account-type", "account-group", "party-type", "party-group", "branch", "city"].forEach((key) => {
            const list = filterPanel?.querySelector(`[data-filter-list="${key}"]`);
            if (!list) return;
            const rows = Array.from(list.querySelectorAll("div"));
            rows.forEach((row, index) => {
              const select = row.querySelector(`[data-filter-${key}]`);
              const mode = row.querySelector(`[data-filter-${key}-mode]`);
              if (select) select.value = "";
              if (mode) mode.value = "include";
              if (index > 0) row.remove();
            });
          });
          if (filterCreatedBy) filterCreatedBy.value = "";
          if (filterCreatedAtStart) filterCreatedAtStart.value = "";
          if (filterCreatedAtEnd) filterCreatedAtEnd.value = "";
          applyFilters();
          updateFilterCount();
          closeFilters();
        });
      }
      filterPanel.addEventListener("click", (event) => {
        if (event.target === filterPanel) {
          closeFilters();
        }
      });
    }

    const addFilterSelect = (type) => {
      const list = filterPanel?.querySelector(`[data-filter-list="${type}"]`);
      if (!list) return;
      const firstSelect = list.querySelector(`[data-filter-${type}]`);
      const firstMode = list.querySelector(`[data-filter-${type}-mode]`);
      if (!firstSelect || !firstMode) return;
      const wrapper = document.createElement("div");
      wrapper.className = "flex items-center gap-2";
      const mode = firstMode.cloneNode(true);
      mode.value = "include";
      const select = firstSelect.cloneNode(true);
      select.value = "";
      const remove = document.createElement("button");
      remove.type = "button";
      remove.className = "rounded-full border border-slate-200 px-2 py-0.5 text-[10px] font-semibold text-slate-500";
      remove.textContent = "x";
      remove.addEventListener("click", () => {
        wrapper.remove();
        updateFilterCount();
        applyFilters();
      });
      wrapper.appendChild(mode);
      wrapper.appendChild(select);
      wrapper.appendChild(remove);
      list.appendChild(wrapper);
      hookFilter(mode);
      hookFilter(select);
      select.addEventListener("change", updateFilterCount);
      mode.addEventListener("change", updateFilterCount);
      updateFilterCount();
    };

    filterAddButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const type = btn.getAttribute("data-filter-add");
        if (!type) return;
        addFilterSelect(type);
      });
    });

    applyFilters();

    const autoOpen = modal && modal.dataset.autoOpen === "true";
    // Re-open modal after server-side validation errors.
    const autoMode = modal && modal.dataset.modalMode ? modal.dataset.modalMode : "create";
    if (autoOpen) {
      let payload = {};
      if (modal && modal.dataset.modalValues) {
        try {
          payload = JSON.parse(modal.dataset.modalValues);
        } catch (err) {
          payload = {};
        }
      }
      openModal(autoMode, payload);
    }
  })();
</script>
<script>
  (function () {
    const i18nSearch = '<%= t("search") %>';
    const i18nSelect = '<%= t("select") %>';
    const isWithinModal = (select) => !!select.closest("[data-modal-form]");
    const isMultiSelectWrapper = (select) => !!select.closest("[data-multi-select]");

    const makePlaceholder = (select) => {
      const label = select.closest("label")?.querySelector("span");
      const labelText = label ? label.textContent.trim() : "";
      return labelText ? `${i18nSearch} ${labelText}` : i18nSearch;
    };

    const createSearchableSelect = (select) => {
      // 1. Validation & Setup
      // MODIFIED: Removed the check for select.multiple so this runs for multi-selects too
      if (!select) return;
      if (!isWithinModal(select) || isMultiSelectWrapper(select)) return;
      if (select.dataset.searchableReady === "true") return;

      const isMulti = select.multiple; // Check if multi-select

      // 2. Identify Placeholder
      let placeholderText = makePlaceholder(select);
      const emptyOption = Array.from(select.options).find((opt) => !opt.value);
      if (emptyOption && emptyOption.textContent.trim()) {
        placeholderText = emptyOption.textContent.trim();
      }

      // 3. Create Wrapper
      const wrapper = document.createElement("div");
      wrapper.className = "relative w-full group";

      // 4. Create the "Combobox" Input
      const input = document.createElement("input");
      input.type = "text";
      input.className = select.className.replace("appearance-none", "") + " pr-10";

      if (!input.className.includes("border")) {
        input.className += " w-full rounded-lg border border-slate-200 bg-slate-50/50 px-3 py-2.5 text-sm text-slate-800 transition focus:border-slate-400 focus:bg-white focus:outline-none focus:ring-4 focus:ring-slate-100";
      }

      input.placeholder = placeholderText;
      input.autocomplete = "off";

      if (select.hasAttribute("required")) {
        input.required = true;
        // For multi-select, we don't remove required from select immediately as browser validation might vary,
        // but typically we rely on the input's required state.
        if (!isMulti) select.removeAttribute("required");
      }

      // 5. Add a Chevron Icon
      const icon = document.createElement("div");
      icon.className = "pointer-events-none absolute right-3 top-1/2 -translate-y-1/2 text-slate-500 transition-transform duration-200 group-focus-within:rotate-180";
      icon.innerHTML = '<svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>';

      // 6. Create the Dropdown Menu
      const menu = document.createElement("div");
      menu.className = "absolute left-0 right-0 z-50 mt-1 hidden max-h-60 overflow-y-auto rounded-xl border border-slate-200 bg-white py-1 shadow-xl ring-1 ring-black/5";

      // --- HELPER: Sync Visible Input with Hidden Select ---
      const syncToInput = () => {
        if (isMulti) {
          // For multi-select, join selected labels with commas
          const labels = Array.from(select.selectedOptions).map((opt) => opt.textContent.trim());
          input.value = labels.length ? labels.join(", ") : "";
        } else {
          const selected = select.options[select.selectedIndex];
          if (selected && selected.value) {
            input.value = selected.textContent.trim();
          } else {
            input.value = "";
          }
        }
      };

      // --- HELPER: Render the List ---
      const renderMenu = () => {
        menu.innerHTML = "";

        // Determine filter term
        let filter = input.value.trim().toLowerCase();

        // If Multi-Select: Don't filter if the input matches the full selected list (user hasn't typed a new search)
        if (isMulti) {
          const currentString = Array.from(select.selectedOptions)
            .map((opt) => opt.textContent.trim())
            .join(", ")
            .toLowerCase();
          if (filter === currentString) filter = "";
        }

        let count = 0;

        Array.from(select.options).forEach((opt) => {
          if (!opt.value) return; // Skip placeholder

          const label = opt.textContent.trim();
          const isMatch = !filter || label.toLowerCase().includes(filter);

          // For single select, exact match logic. For multi, we rely on includes.
          const isExactMatch = !isMulti && input.value.trim() === label;

          if (!isMatch && !isExactMatch) return;

          count++;
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = `flex w-full items-center justify-between px-4 py-2.5 text-left text-sm transition hover:bg-slate-50 ${opt.selected ? "bg-slate-50 text-slate-900 font-medium" : "text-slate-600"}`;

          // MODIFIED: Checkbox UI for Multi, Tick for Single
          let iconHtml = "";
          if (isMulti) {
            iconHtml = opt.selected
              ? '<svg class="h-4 w-4 text-emerald-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" /></svg>' // Checked
              : '<span class="h-4 w-4 block border border-slate-300 rounded-sm"></span>'; // Unchecked box placeholder
          } else {
            iconHtml = opt.selected ? '<svg class="h-4 w-4 text-emerald-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" /></svg>' : "";
          }

          btn.innerHTML = `<span>${label}</span>${iconHtml}`;

          btn.addEventListener("mousedown", (e) => {
            e.preventDefault();

            if (isMulti) {
              // MODIFIED: Toggle selection for multi
              opt.selected = !opt.selected;
              select.dispatchEvent(new Event("change", { bubbles: true }));
              syncToInput();
              // Re-render menu to update checkboxes, keep menu open
              renderMenu();
              // Keep focus on input so user can keep searching/selecting
              input.focus();
            } else {
              // Original Single Select Logic
              select.value = opt.value;
              select.dispatchEvent(new Event("change", { bubbles: true }));
              syncToInput();
              menu.classList.add("hidden");
            }
          });

          menu.appendChild(btn);
        });

        if (count === 0) {
          const empty = document.createElement("div");
          empty.className = "px-4 py-3 text-xs text-slate-400 text-center italic select-none";
          empty.textContent = "No matches found";
          menu.appendChild(empty);
        }
      };

      // 7. Event Listeners
      input.addEventListener("focus", () => {
        input.select(); // Select all text so user can easily overwrite
        renderMenu();
        menu.classList.remove("hidden");
      });

      input.addEventListener("input", () => {
        renderMenu();
        menu.classList.remove("hidden");
      });

      input.addEventListener("blur", () => {
        setTimeout(() => {
          menu.classList.add("hidden");

          if (isMulti) {
            // For multi, always re-sync to show full selection list on blur (clearing any partial search text)
            syncToInput();
          } else {
            // Original Single Select Validation Logic
            const val = input.value.trim().toLowerCase();
            const match = Array.from(select.options).find((opt) => opt.value && opt.textContent.trim().toLowerCase() === val);

            if (match) {
              if (select.value !== match.value) {
                select.value = match.value;
                select.dispatchEvent(new Event("change", { bubbles: true }));
              }
            } else {
              if (val === "") {
                select.value = "";
                select.dispatchEvent(new Event("change", { bubbles: true }));
              } else {
                syncToInput();
              }
            }
          }
        }, 150);
      });

      select.addEventListener("change", syncToInput);

      // 8. DOM Assembly
      select.classList.add("sr-only");
      select.dataset.searchableReady = "true";

      select.parentNode.insertBefore(wrapper, select);

      wrapper.appendChild(input);
      wrapper.appendChild(icon);
      wrapper.appendChild(menu);
      wrapper.appendChild(select);

      syncToInput();
    };

    const initSearchableSelects = () => {
      document.querySelectorAll("select").forEach((select) => {
        // MODIFIED: Removed the check for select.multiple
        if (!select) return;
        if (select.dataset.searchableSkip === "true") return;
        createSearchableSelect(select);
      });
    };

    document.addEventListener("DOMContentLoaded", initSearchableSelects);
    window.initSearchableSelects = initSearchableSelects;
  })();
</script>

<script>
  (function () {
    // GENERIC EDIT LOADER (Fixes Dropdowns & Inputs for all Modals)
    const modalForm = document.querySelector("[data-modal-form]");

    if (modalForm) {
      const fillFormFromButton = (button) => {
        // Loop through every input/select in the form
        Array.from(modalForm.elements).forEach((input) => {
          if (!input.name) return;

          // Try to find matching data on the button (e.g. name="group_id" -> data-group_id)
          const val = button.getAttribute(`data-${input.name}`);

          if (val !== null && val !== undefined) {
            // Handle Checkboxes
            if (input.type === "checkbox") {
              input.checked = val === "true" || val === "1" || val === "on";
            }
            // Handle Radios (only check if value matches)
            else if (input.type === "radio") {
              if (input.value === val) input.checked = true;
            }
            // Handle Multi-Selects (MODIFIED)
            else if (input.tagName === "SELECT" && input.multiple) {
              // Assume values are comma-separated in the data attribute
              const values = String(val)
                .split(",")
                .map((v) => v.trim());
              Array.from(input.options).forEach((opt) => {
                opt.selected = values.includes(opt.value);
              });
            }
            // Handle Standard Inputs & Selects
            else {
              input.value = val;
            }

            // CRITICAL FIX: Trigger 'change' event manually.
            input.dispatchEvent(new Event("change", { bubbles: true }));
          }
        });
      };

      // Attach listener to document to catch all Edit buttons (even dynamically added ones)
      document.addEventListener("click", (event) => {
        const editBtn = event.target.closest("[data-edit]");
        if (editBtn) {
          // Reset form first to clear old errors/values
          modalForm.reset();

          // Clear multi-selects explicitly as reset() might not handle visual sync immediately
          modalForm.querySelectorAll("select[multiple] option").forEach((opt) => (opt.selected = false));

          // Small delay to ensure modal is visible/ready before filling
          setTimeout(() => {
            fillFormFromButton(editBtn);
          }, 10);
        }
      });

      // Auto-open logic (for Server-Side errors)
      const modal = document.querySelector("[data-modal]");
      if (modal && modal.dataset.autoOpen === "true" && modal.dataset.modalMode === "edit") {
        const currentId = modal.dataset.currentId;
        const targetBtn = document.querySelector(`[data-edit][data-id="${currentId}"]`);
        if (targetBtn) setTimeout(() => fillFormFromButton(targetBtn), 50);
      }
    }
  })();
</script>
